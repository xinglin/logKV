// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/LogKeyValue.h"
#include "Log.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <unordered_map>
#include <string>
#include <iostream>
#include <atomic>
#include <csignal>
#include <filesystem>         // check file exist
#include <thread>             // for background garbage collection thread
#include <condition_variable> // for signal gc thread and gc thread sleep.
#include <mutex>
#include <chrono>
#include <exception>
using namespace std::chrono_literals;

namespace fs = std::filesystem;
using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

int verboseLevel = 10;

struct SequenceFlag
{
  SequenceNumber seqNum{0};
  Flag flag{0};
  SequenceFlag() = default;
  SequenceFlag(SequenceNumber seqNum, Flag flag) : seqNum(seqNum), flag(flag) {}
};

typedef unordered_map<string, SequenceNumber> KeySeqMap;
typedef unordered_map<string, LogLocator> KeyLocMap;

class LogKeyValueHandler : virtual public LogKeyValueIf
{
  atomic<SequenceNumber> seqNum{0};         // seq number for each put and delete operation.
  string dir;                               // dir to store logkv files.
  shared_ptr<Logger> putLog, delLog, gcLog; // logger for regular puts, deletes, and garbage collection.

  shared_ptr<thread> gcThread;
  mutex mGC;
  condition_variable cvGC;

  KeyLocMap kvMap;      // key -> log location mapping for valid kv pairs. 
  unordered_map<FileID, LogFile *> openedLogs; // logs that have been opened for reads.

  // given a log file name (not a file path!), such as log_fileno.kv, return fileno.
  FileID getFileID(string file)
  {
    int len = file.size();
    FileID fileno = 0;

    try {
      fileno = stoul(file.substr(4, len - 7));
    } catch (std::invalid_argument &e) {
      cerr << "getFileID() error for " << file 
        << ": stoul invalid argument" << endl;
      exit(EXIT_FAILURE);
    }

    return fileno;
  }

  void rebuildkvMap(const vector<FileID> &logfiles);
  void reclaimLogFile(LogFile *l, KeySeqMap &deletedKVMap);
  void reclaimDeleteLogs(vector<LogFile*> &logs, KeySeqMap &deletedKVMap);
  void reclaimDeleteLog(LogFile* log, KeySeqMap &deletedKVMap);
  void garbageCollector();
  vector<FileID> listLogFiles();

  bool CheckKVRecord(const string& key, const LogLocator &loc);
  bool CheckDeleteRecord(const string& key, const SequenceNumber seqNum, 
                          KeySeqMap &deletedKVMap);

public:
  LogKeyValueHandler(string dir) : dir(dir)
  {
    startup();

    putLog = make_shared<Logger>(dir, "put");
    delLog = make_shared<Logger>(dir, "del");
    gcLog = make_shared<Logger>(dir, "garbage collection");

    gcThread = make_shared<thread>(&LogKeyValueHandler::garbageCollector, this);
  }
  void startup();
  void shutdown();

  // handle a put request
  void Put(Response &_return, const std::string &key, const std::string &value)
  {
    cout << "Put: key=" << key << ", value=" << value << ", seq=" << seqNum << endl;
    LogLocator loc;
    putLog->append(key, value, 0, seqNum.fetch_add(1), loc);
    kvMap[key] = loc;
    if (verboseLevel > 5)
      cout << "key " << key << " stored at file:offset " << loc.fileno << ":" << loc.offset << endl;
    _return.status = true;
  }

  // handle a get request
  void Get(Response &_return, const std::string &key)
  {
    cout << "Get: key=" << key << endl;
    _return.status = false;

    // do nothing if couldn't find the requested key
    if (kvMap.find(key) == kvMap.end())
    {
      return;
    }

    LogLocator loc = kvMap[key];
    if (verboseLevel > 5)
      cout << "key is at file:offset = " << loc.fileno << ":" << loc.offset << endl;
    if (openedLogs.find(loc.fileno) == openedLogs.end())
      openedLogs[loc.fileno] = new LogFile(loc.fileno, dir);

    LogFile *log = openedLogs[loc.fileno];

    // do not use __set_value from Reponse, to reduce one more copy.
    log->loadValue(loc.offset, _return.value);
    _return.__isset.value = true; // need to mark value is set in __isset
    //cout <<"_return.value = " << _return.value << endl;
    _return.status = true;
  }

  // handle a delete request
  void Delete(Response &_return, const std::string &key)
  {
    cout << "Delete: key=" << key << endl;
    _return.status = false;
    int flag = 1 << FLAG_BIT_DELETE;
    if (kvMap.find(key) != kvMap.end())
    {
      delLog->appendDelete(key, flag, seqNum.fetch_add(1));
      kvMap.erase(key);
      _return.status = true;
    }
  }

  // handle an exist request
  void Exist(Response &_return, const std::string &key)
  {
    _return.status = (kvMap.find(key) != kvMap.end());
  }
};

//atomic<FileID> LogKeyValueHandler::seqNum(0);

// Rebuild the kvMap during a restart 
void LogKeyValueHandler::rebuildkvMap(const vector<FileID> &logfiles)
{

  // map from key to <sequence number, flag> pair
  unordered_map<string, SequenceFlag> keyStatusMap;
  uint64_t maxSeqNum = 0, maxLogFileID = 0;

  for (auto fileno : logfiles)
  {
    if (fileno > maxLogFileID)
      maxLogFileID = fileno;

    LogFile l(fileno, dir);

    l.deserializeFooter();

    vector<FooterEntry> &entries = l.getFooterEntries();
    for (auto &e : entries)
    {
      if (e.seqNum > maxSeqNum)
        maxSeqNum = e.seqNum;

      if (keyStatusMap.find(e.key) == keyStatusMap.end())
      {
        // first time to see this key

        // not a delete record, insert into kvMap
        if (!FlagDeleteBit(e.flag))
          kvMap[e.key] = LogLocator(fileno, e.offset);

        keyStatusMap[e.key] = SequenceFlag(e.seqNum, e.flag);
      }
      else
      {
        // if this is an earlier version, skip
        if (e.seqNum < keyStatusMap[e.key].seqNum)
          continue;
        else
        {
          keyStatusMap[e.key] = SequenceFlag(e.seqNum, e.flag);

          // A more recent Put
          if (!FlagDeleteBit(e.flag))
          {
            kvMap[e.key] = LogLocator(fileno, e.offset);
          }
          else
          {
            // a more recent Del

            // remove key from kvMap if it exists
            if (kvMap.find(e.key) != kvMap.end())
              kvMap.erase(e.key);
          }
        }
      }
    }
  }

  if (verboseLevel > 5)
    cout << "maxFileID=" << maxLogFileID << ", maxSequenceNum = " << maxSeqNum << endl;
  seqNum.store(maxSeqNum + 1);
  LogFile::setNextFileID(maxLogFileID + 1);
}

bool LogKeyValueHandler::CheckKVRecord(const string& key, const LogLocator& loc) 
{
  if(kvMap.find(key) == kvMap.end() || kvMap[key] != loc)
    return false;
  else
    return true;
}

/* background garbage collection thread. */
void LogKeyValueHandler::garbageCollector()
{
  
  while (true)
  {

    unique_lock<mutex> lk(mGC);
    cvGC.wait_for(lk, GC_INTERVAL);
    lk.unlock();

    cout << "Garbage collection is running." << endl;
  
    KeySeqMap deletedKVMap;   // key -> sequenceNum of last Put for that key
    vector<LogFile*> deletelogs;                          // delete logs

    vector<FileID> logfiles = listLogFiles();

    for (auto fileno : logfiles)
    {
      LogFile *l = new LogFile(fileno, dir);

      l->deserializeFooter();

      // skip delete logs. delete logs are processed in a second pass.
      if (l->isDeleteLog()) {
        deletelogs.push_back(l);
        continue;
      }

      // total and invalid bytes for kv pairs in a log file.
      // only consider keyLen and valueLen and ignore metadata fields.
      Offset totalBytes = 0, invalidBytes = 0;

      vector<FooterEntry> &entries = l->getFooterEntries();
      for (auto &e : entries)
      {
        totalBytes += (e.keyLen + e.valLen);

        LogLocator loc(fileno, e.offset);
        if (!CheckKVRecord(e.key, loc))
        {
          // invalid kv pair.
          invalidBytes += (e.keyLen + e.valLen);

          // update deleteKVMap with sequenceNumber for the most recent Put 
          if(deletedKVMap.find(e.key) == deletedKVMap.end() || 
            deletedKVMap[e.key] < e.seqNum)
            deletedKVMap[e.key] = e.seqNum;
        }
      }

      // calculate the percentage of valid data in this log file
      double valid = (totalBytes - invalidBytes) / (double)totalBytes;
      if (entries.empty() || valid < GC_THRESHOLD)
      {
        // ok to remove the log file in reclaimLogFile.
        // the file will be removed when l->close() is called.
        reclaimLogFile(l, deletedKVMap);
      } 

      l->close();
      
    }

    reclaimDeleteLogs(deletelogs, deletedKVMap);

    // close remaining opened delete logs
    for(auto& log: deletelogs)
      log->close();
  }
}

/* 
 * Reclaim a sparse log file
 * 
 * This function reclaims log files containing regular kv pairs (putlog and gclog), 
 * but not delete records.
 */ 
void LogKeyValueHandler::reclaimLogFile(LogFile *l, KeySeqMap &deletedKVMap)
{
  if (verboseLevel > 5)
    cout << "reclaim log file: " << l->getLogFileName() << endl;

  FileID fileno = l->getFileID();

  for (auto &e : l->getFooterEntries())
  {
    LogLocator loc(fileno, e.offset);
    if (CheckKVRecord(e.key, loc))
    {
      // valid kv pair. need to migrate to the current gc log file.
      LogLocator newLoc;
      string value;
      l->loadValue(e.offset, value);

      // write to gc Log
      gcLog->append(e.key, value, e.flag, e.seqNum, newLoc);

      // update kvmap
      kvMap[e.key] = newLoc;
    } 
  }

  if (!fs::remove(l->getLogFileName()))
  {
    cout << "[WARNING]: gc failed to remove log file: " << l->getLogFileName() << endl;
  }
}

// Check whether this is a valid delete record that we still need to migrate
// during garbage collection. 
bool LogKeyValueHandler::CheckDeleteRecord(const string& key, 
                      const SequenceNumber seqNum,
                      KeySeqMap &deletedKVMap)
{
  if(kvMap.find(key) != kvMap.end()) {
    return false;
  } else {
    if(deletedKVMap.find(key) == deletedKVMap.end() || 
        seqNum < deletedKVMap[key])
      return false; 
  }

  return true;
}
/* 
 * Reclaim delete logs. 
 * 
 * Called by garbageCollector, after reclaiming putlogs and gclogs. 
 */
void LogKeyValueHandler::reclaimDeleteLogs(vector<LogFile*> &logs, 
                      KeySeqMap &deletedKVMap)
{
  for(auto& log: logs) {

    // 1. analyze whether a delete log file should be reclaimed. 
    Offset totalBytes = 0, invalidBytes = 0;
    vector<FooterEntry>& entries = log->getFooterEntries();
    for(auto& e: entries) {
      totalBytes += (e.keyLen + e.valLen);

      if(!CheckDeleteRecord(e.key, e.seqNum, deletedKVMap))
        invalidBytes += (e.keyLen + e.valLen);
    }

    // 2. migrate needed delete records
    double valid = (totalBytes - invalidBytes)/(double)totalBytes;
    if(entries.empty() || valid < GC_THRESHOLD) 
      reclaimDeleteLog(log, deletedKVMap);
  }
}

/* reclaim a single delete log */
void LogKeyValueHandler::reclaimDeleteLog(LogFile* log, 
    KeySeqMap &deletedKVMap) 
{
  if(verboseLevel > 5)
    cout << "reclaim deletelog: " << log->getLogFileName() << endl;

  for(auto& e: log->getFooterEntries()) {
    if(CheckDeleteRecord(e.key, e.seqNum, deletedKVMap))
        delLog->appendDelete(e.key, e.flag, e.seqNum);
  }

  if (!fs::remove(log->getLogFileName()))
  {
    cout << "[WARNING]: gc failed to remove delete log : " << log->getLogFileName() << endl;
  }
}

/*
 * Scan the dir and return a list of IDs for log file.
 *
 * FileIDs are sorted before returning to the caller.
 */
vector<FileID> LogKeyValueHandler::listLogFiles()
{

  vector<FileID> logfiles;
  for (auto &p : fs::directory_iterator(dir))
  {
    if (fs::is_regular_file(p.path()))
    {
      if (LogFile::isLogFile(p.path().filename()))
      {
        cout << "find log file: " << p.path().filename() << endl;
        logfiles.push_back(getFileID(p.path().filename()));
      }
      else
        cout << "find active log file: " << p.path().filename() << endl;
    }
  }

  // sort log files by fileID
  sort(logfiles.begin(), logfiles.end());

  return std::move(logfiles);
}

void LogKeyValueHandler::startup()
{
  cout << "kv server is starting..." << endl;

  vector<FileID> logfiles = listLogFiles();
  rebuildkvMap(logfiles);
}

void LogKeyValueHandler::shutdown()
{
  // shutdown loggers for putlog, dellog and gclog.
  putLog->shutdown();
  delLog->shutdown();
  gcLog->shutdown();

  // close all opened log files
  for (auto it = openedLogs.begin(); it != openedLogs.end(); it++)
  {
    it->second->close();
  }
}

::std::shared_ptr<LogKeyValueHandler> handler;

void shutdown(int signum)
{
  cout << "shutdown..." << endl;

  handler->shutdown();

  exit(signum);
}

void usage(char *app)
{
  cerr << "Usage: " << app << " [-d dir]" << endl;
  exit(EXIT_FAILURE);
}

void getOptions(int argc, char **argv, string &dir)
{

  int opt;
  while ((opt = getopt(argc, argv, "d:")) != -1)
  {
    switch (opt)
    {
    case 'd':
      dir.assign(optarg);
      break;
    default:
      usage(argv[0]);
    }
  }
}

int main(int argc, char **argv)
{
  string dir;

  // register a handler for ctrl+C for graceful shutdown
  signal(SIGINT, shutdown);

  getOptions(argc, argv, dir);
  if (dir.empty())
    dir = fs::current_path();
  if (!fs::exists(dir) || !fs::is_directory(dir))
  {
    cout << "dir [" << dir << "] does not exit or is not a dir." << endl;
    exit(EXIT_FAILURE);
  }
  dir = fs::absolute(dir);
  if (verboseLevel > 5 && !dir.empty())
    cout << "dir = " << dir << endl;

  int port = 9090;
  handler = std::make_shared<LogKeyValueHandler>(dir);
  ::std::shared_ptr<TProcessor> processor(new LogKeyValueProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}
